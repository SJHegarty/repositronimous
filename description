I've grown tired of the way this shit is done, I don't quite like the way that git works - and other people don't like my mitigations.
So I'm doing my own.
It sounds like an interesting enough technical problem.
  TODO:
     - Tabs or go fuck yourself
     - Meta-Yaks
       - Write a code formatter.
        - Write an indent detector. For example, the aweful github thing spat out this two space indented by default monstrosity.
          - bash scripts.
           - detect spaces or tabs
           - if spaces
            - someone can go fuck themselves
            - greatest common divisor (across all lines) of the number of spaces preceeding first visible content of the line.
             - replace those spaces with number divided by the gcd
       - Ultimately write your own web text editor, run locally commit locally, backup remotely.
        - Ride your horse on the moon and do a backflip
      - 3D shapeshifting robot and other important branding related aspects

    Code of Conduct:
      If you want one, by all means feel free to bend over, reach up your own arse, and go searching.
    Compatability:
      Interoperability with the git ecosystem
    Data Structures:
      Generalised DAG node structures
      DAG node implementation that implements a graph structure
      Graph-Isomorphic value hashing
        All roads should lead to Rome (I only think about the Roman empire with metaphors like this, but I do spend time thinking about the amount of time I fail to spend thinking about the Roman empire).
          If I have a src-state S and a dst-state D and a delta Δ with the relationship:
            S + Δ = D;
          Then I want also to have the delta negative relationship:
            D - Δ = S;
          And I want the two things to be treated as the same.
            .hash(D) ≡ .hash(S + Δ);
            .hash(S) ≡ .hash(D - Δ);
          (In all cases without and or before programmatic post-processing) if two objects represent directories that are both structurally an informationally equivalent, they should hash to the same values (regardless of how they are structured).
            For example:
              S + ΔA = I;
              I + ΔB = D; 
              


              S
